---
import type { ImageMetadata } from 'astro'
import WorkItem from '@components/WorkItem.astro'
import { Image } from 'astro:assets'

const logoModules = import.meta.glob<{ default: ImageMetadata }>('/src/logos/*.svg', { eager: true })

const { folder = 'work' } = Astro.props

// Preload both collections; choose one based on the `folder` prop.
const collections = {
  work: import.meta.glob('/src/pages/work/*.astro'),
  projects: import.meta.glob('/src/pages/projects/*.astro'),
} as const

const selected = collections[folder] ?? {}

const itemPaths = Object.keys(selected).map(
  (path) => `/${folder}/` + (path.match(new RegExp(`/${folder}/(.*)\\.astro$`))?.[1] ?? ''),
)

const itemModules = await Promise.all(Object.values(selected).map((loader) => loader()))

const itemsUnsorted = itemModules.map((item, i) => ({
  ...item.frontmatter,
  url: itemPaths[i],
  component: item.default,
}))

const items = itemsUnsorted
  .map((item) => {
    const logoFilename = item.logo
    const logoKey = logoFilename ? Object.keys(logoModules).find((k) => k.endsWith(`/${logoFilename}`)) : undefined
    const logoSrc: ImageMetadata | undefined = logoKey ? logoModules[logoKey].default : undefined
    return { ...item, logoSrc }
  })
  .sort((a, b) => b.order - a.order)
---

<div class="work-list-wrap" xyz="fade stagger-1 delay-10 down-2 small-2">
  {
    items.map((item) => (
      <WorkItem
        href={item.url}
        color={item.color}
        order={item.order}
        class="work-list-item xyz-in"
        transitionName={`work-${item.title.toLowerCase().replace(/\s+/g, '-')}-hero`}
      >
        {item.logoSrc ? (
          <Image class="work-item-logo" src={item.logoSrc} alt={`${item.title} Logo`} />
        ) : (
          <h3 class="work-item-title">{item.title}</h3>
        )}
      </WorkItem>
    ))
  }
</div>

<script>
  // A major pentatonic spanning 2 octaves: A3â†’A4, so order 1 = bass, order 4 = soprano
  const NOTE_FREQS = [220.0, 277.18, 329.63, 440.0, 554.37]

  let audioCtx: AudioContext | null = null
  let reverbNode: ConvolverNode | null = null

  function initAudioContext() {
    if (audioCtx) return
    audioCtx = new AudioContext()
  }

  // AudioContext can only be created after a real user gesture (click/keydown).
  // mouseenter is not sufficient, so we initialize eagerly on first interaction.
  document.addEventListener('pointerdown', initAudioContext, { once: true })
  document.addEventListener('keydown', initAudioContext, { once: true })

  function getCtx(): AudioContext | null {
    if (!audioCtx) return null
    if (audioCtx.state === 'suspended') {
      audioCtx.resume()
    }
    return audioCtx
  }

  function ensureReverb(ctx: AudioContext): ConvolverNode {
    if (reverbNode) return reverbNode
    const rate = ctx.sampleRate
    const length = rate * 2.0
    const impulse = ctx.createBuffer(2, length, rate)
    for (let ch = 0; ch < 2; ch++) {
      const data = impulse.getChannelData(ch)
      for (let i = 0; i < length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.0)
      }
    }
    reverbNode = ctx.createConvolver()
    reverbNode.buffer = impulse
    reverbNode.connect(ctx.destination)
    return reverbNode
  }

  function isMuted(): boolean {
    return document.documentElement.dataset.soundMuted === 'true'
  }

  function playNote(order: number) {
    if (isMuted()) return
    const ctx = getCtx()
    if (!ctx) return
    const freq = NOTE_FREQS[Math.min(order - 1, NOTE_FREQS.length - 1)]
    const now = ctx.currentTime
    const duration = 1.4

    const dry = ctx.createGain()
    const wet = ctx.createGain()
    dry.gain.value = 0.75
    wet.gain.value = 0.5

    const reverb = ensureReverb(ctx)
    dry.connect(ctx.destination)
    wet.connect(reverb)

    // Chorus voices: [freqMult, detuneCents, gainLevel, attackDelay, vibratoRate, vibratoDepth]
    const voices: [number, number, number, number, number, number][] = [
      [0.5,   0, 0.05, 0.000, 0.0,  0],   // sub octave for body
      [1,   -22, 0.09, 0.010, 5.1, 11],   // choir voice 1
      [1,    -9, 0.10, 0.005, 5.6,  9],   // choir voice 2
      [1,     0, 0.11, 0.000, 6.0, 10],   // fundamental
      [1,     9, 0.10, 0.005, 5.3,  9],   // choir voice 3
      [1,    22, 0.09, 0.010, 4.9, 11],   // choir voice 4
      [2,    -9, 0.04, 0.003, 5.8,  8],   // octave up (detuned)
      [2,     9, 0.04, 0.003, 5.2,  8],   // octave up (opposite)
      [1.498, 0, 0.025, 0.000, 5.5, 7],   // fifth harmonic shimmer
    ]

    for (const [freqMult, detune, level, atkDelay, lfoRate, lfoDepth] of voices) {
      const osc = ctx.createOscillator()
      const gain = ctx.createGain()
      osc.type = 'sine'
      osc.frequency.value = freq * freqMult
      osc.detune.value = detune

      // Per-voice vibrato kicks in after a short delay for organic feel
      if (lfoRate > 0) {
        const lfo = ctx.createOscillator()
        const lfoGain = ctx.createGain()
        lfo.frequency.value = lfoRate
        lfoGain.gain.setValueAtTime(0, now)
        lfoGain.gain.linearRampToValueAtTime(lfoDepth, now + 0.18)
        lfo.connect(lfoGain)
        lfoGain.connect(osc.detune)
        lfo.start(now + 0.06)
        lfo.stop(now + duration)
      }

      osc.connect(gain)
      gain.connect(dry)
      gain.connect(wet)

      const start = now + atkDelay
      gain.gain.setValueAtTime(0, start)
      gain.gain.linearRampToValueAtTime(level, start + 0.02)
      gain.gain.exponentialRampToValueAtTime(level * 0.55, start + 0.22)
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration)

      osc.start(start)
      osc.stop(now + duration)
    }
  }

  function initHoverSounds() {
    if (!window.matchMedia('(pointer: fine)').matches) return
    const items = document.querySelectorAll<HTMLElement>('.work-item-wrap[data-order]')
    items.forEach((item) => {
      if (item.dataset.soundBound === 'true') return
      item.dataset.soundBound = 'true'
      item.addEventListener('mouseenter', () => {
        const order = parseInt(item.dataset.order ?? '1', 10)
        playNote(order)
      })
    })
  }

  document.addEventListener('astro:page-load', initHoverSounds)
</script>

<style lang="scss">
  @use '../styles/_scssVariables' as *;

  .work-list-wrap {
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: stretch;
    gap: var(--spacing-11);
    transform-style: preserve-3d;

    @media (width < $breakpoint-md) {
      gap: var(--spacing-10);
    }

    @media (width < $breakpoint-sm) {
      gap: var(--spacing-8);
    }

    :global(.work-item-wrap) {
      height: 11rem;

      @media (width < $breakpoint-sm) {
        height: 7rem;
      }
    }
  }

  .work-item-logo {
    display: block;
    width: 100%;
    height: auto;
    max-width: 15rem;
    max-height: 3rem;
    margin: 0 auto;

    @media (width < $breakpoint-md) {
      max-width: 12rem;
      max-height: 2.5rem;
    }

    @media (width < $breakpoint-sm) {
      max-width: 8rem;
      max-height: 2rem;
    }
  }

  .work-item-title {
    display: block;
    font-size: 1.6em;
    font-weight: 300;
    text-align: center;
  }

  .work-item-details {
    display: block;
    color: rgba(255, 255, 255, 0.75);
  }
</style>
