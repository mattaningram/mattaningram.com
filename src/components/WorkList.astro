---
import type { ImageMetadata } from 'astro'
import WorkItem from '@components/WorkItem.astro'
import { Image } from 'astro:assets'

const logoModules = import.meta.glob<{ default: ImageMetadata }>('/src/logos/*.svg', { eager: true })

const { folder = 'work' } = Astro.props

// Preload both collections; choose one based on the `folder` prop.
const collections = {
  work: import.meta.glob('/src/pages/work/*.astro'),
  projects: import.meta.glob('/src/pages/projects/*.astro'),
} as const

const selected = collections[folder] ?? {}

const itemPaths = Object.keys(selected).map(
  (path) => `/${folder}/` + (path.match(new RegExp(`/${folder}/(.*)\\.astro$`))?.[1] ?? ''),
)

const itemModules = await Promise.all(Object.values(selected).map((loader) => loader()))

const itemsUnsorted = itemModules.map((item, i) => ({
  ...item.frontmatter,
  url: itemPaths[i],
  component: item.default,
}))

const items = itemsUnsorted
  .map((item) => {
    const logoFilename = item.logo
    const logoKey = logoFilename ? Object.keys(logoModules).find((k) => k.endsWith(`/${logoFilename}`)) : undefined
    const logoSrc: ImageMetadata | undefined = logoKey ? logoModules[logoKey].default : undefined
    return { ...item, logoSrc }
  })
  .sort((a, b) => b.order - a.order)
---

<div class="work-list-wrap" xyz="fade stagger-1 delay-10 down-2 small-2">
  {
    items.map((item) => (
      <WorkItem
        href={item.url}
        color={item.color}
        order={item.order}
        class="work-list-item xyz-in"
        transitionName={`work-${item.title.toLowerCase().replace(/\s+/g, '-')}-hero`}
      >
        {item.logoSrc ? (
          <Image class="work-item-logo" src={item.logoSrc} alt={`${item.title} Logo`} />
        ) : (
          <h3 class="work-item-title">{item.title}</h3>
        )}
      </WorkItem>
    ))
  }
</div>

<script>
  // A major pentatonic scale: A4, B4, C#5, E5, F#5
  const NOTE_FREQS = [440, 493.88, 554.37, 659.25, 739.99]

  let audioCtx: AudioContext | null = null
  let reverbNode: ConvolverNode | null = null

  function getCtx(): AudioContext {
    if (!audioCtx) {
      audioCtx = new AudioContext()
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume()
    }
    return audioCtx
  }

  function ensureReverb(ctx: AudioContext): ConvolverNode {
    if (reverbNode) return reverbNode
    const rate = ctx.sampleRate
    const length = rate * 1.5
    const impulse = ctx.createBuffer(2, length, rate)
    for (let ch = 0; ch < 2; ch++) {
      const data = impulse.getChannelData(ch)
      for (let i = 0; i < length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5)
      }
    }
    reverbNode = ctx.createConvolver()
    reverbNode.buffer = impulse
    reverbNode.connect(ctx.destination)
    return reverbNode
  }

  function isMuted(): boolean {
    return document.documentElement.dataset.soundMuted === 'true'
  }

  function playNote(order: number) {
    if (isMuted()) return
    const ctx = getCtx()
    const freq = NOTE_FREQS[Math.min(order - 1, NOTE_FREQS.length - 1)]
    const now = ctx.currentTime
    const duration = 0.8

    const dry = ctx.createGain()
    const wet = ctx.createGain()
    dry.gain.value = 0.85
    wet.gain.value = 0.3

    const reverb = ensureReverb(ctx)
    dry.connect(ctx.destination)
    wet.connect(reverb)

    // Voice definitions: [freqMultiplier, detuneInCents, type, gainLevel]
    const voices: [number, number, OscillatorType, number][] = [
      [0.5, 0, 'sine', 0.06],       // sub octave for warmth
      [1, 0, 'sine', 0.12],          // fundamental
      [1, 6, 'sine', 0.08],          // slight detune for chorus
      [1, -6, 'sine', 0.08],         // opposite detune for width
      [2, 0, 'sine', 0.05],          // octave harmonic
      [1.498, 0, 'sine', 0.03],      // fifth harmonic (soft shimmer)
    ]

    for (const [freqMult, detune, type, level] of voices) {
      const osc = ctx.createOscillator()
      const gain = ctx.createGain()
      osc.type = type
      osc.frequency.value = freq * freqMult
      osc.detune.value = detune

      osc.connect(gain)
      gain.connect(dry)
      gain.connect(wet)

      gain.gain.setValueAtTime(0, now)
      gain.gain.linearRampToValueAtTime(level, now + 0.015)
      gain.gain.exponentialRampToValueAtTime(level * 0.4, now + 0.15)
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration)

      osc.start(now)
      osc.stop(now + duration)
    }
  }

  function initHoverSounds() {
    if (!window.matchMedia('(pointer: fine)').matches) return
    const items = document.querySelectorAll<HTMLElement>('.work-item-wrap[data-order]')
    items.forEach((item) => {
      if (item.dataset.soundBound === 'true') return
      item.dataset.soundBound = 'true'
      item.addEventListener('mouseenter', () => {
        const order = parseInt(item.dataset.order ?? '1', 10)
        playNote(order)
      })
    })
  }

  document.addEventListener('astro:page-load', initHoverSounds)
</script>

<style lang="scss">
  @use '../styles/_scssVariables' as *;

  .work-list-wrap {
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: stretch;
    gap: var(--spacing-11);
    transform-style: preserve-3d;

    @media (width < $breakpoint-md) {
      gap: var(--spacing-10);
    }

    @media (width < $breakpoint-sm) {
      gap: var(--spacing-8);
    }

    :global(.work-item-wrap) {
      height: 11rem;

      @media (width < $breakpoint-sm) {
        height: 7rem;
      }
    }
  }

  .work-item-logo {
    display: block;
    width: 100%;
    height: auto;
    max-width: 15rem;
    max-height: 3rem;
    margin: 0 auto;

    @media (width < $breakpoint-md) {
      max-width: 12rem;
      max-height: 2.5rem;
    }

    @media (width < $breakpoint-sm) {
      max-width: 8rem;
      max-height: 2rem;
    }
  }

  .work-item-title {
    display: block;
    font-size: 1.6em;
    font-weight: 300;
    text-align: center;
  }

  .work-item-details {
    display: block;
    color: rgba(255, 255, 255, 0.75);
  }
</style>
